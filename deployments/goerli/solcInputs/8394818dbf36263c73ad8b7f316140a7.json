{
  "language": "Solidity",
  "sources": {
    "contracts/NotificationService.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\n// Custome errors\nerror NotificationService__ZeroAddress();\nerror NotificationService__ChannelAlreadyCreated();\nerror NotificationService__ChannelDoesNotExist();\nerror NotificationService__NotAdmin();\nerror NotificationService__NotADelegate();\nerror NotificationService__ChannelNotActive();\nerror NotificationService__ChannelNotMuted();\nerror NotificationService__UserNotSubscribed();\nerror NotificationService__NeitherAdminNorDelegate();\nerror NotificationService__UserAlreadySubscribed();\n\ncontract NotificationService {\n    //enum and struct definitions\n    enum ChannelState {\n        ACTIVE,\n        MUTED,\n        DELETED\n    }\n\n    struct Channel {\n        address channelAddress;\n        address admin;\n        string channelName;\n        string channelDescription;\n        ChannelState channelState;\n        address[] delegates;\n        address[] subsribers;\n    }\n\n    struct Subscription {\n        address channelAddress;\n        address user;\n        uint256 subscriberIndex;\n    }\n\n    struct Delegate {\n        address channelAddress;\n        address delegate;\n        uint256 delegateIndex;\n    }\n\n    struct Notification {\n        address channelAddress;\n        address recipient;\n        string message;\n    }\n\n    // state variables\n    mapping(address => mapping(address => Subscription)) channelAddressToUserSubscription;\n    mapping(address => mapping(address => Delegate)) channelAddressToDelegate;\n    mapping(address => Channel) private channelAddressToChannel;\n    uint256 public channelCounter;\n\n    // Events\n    event ChannelCreated(\n        address indexed channelAddress,\n        address indexed admin,\n        string channelName,\n        string channelDescription\n    );\n    event DelegateAdded(address indexed channelAddress, address indexed delegate);\n    event DelegateRemoved(address indexed channelAddress, address indexed delegate);\n    event ChannelMuted(address indexed channelAddress);\n    event ChannelUnmuted(address indexed channelAddress);\n    event ChannelDeleted(address indexed channelAddress);\n    event NotificationGenerated(\n        address indexed channelAddress,\n        address indexed recipient,\n        Notification notification\n    );\n    event UserSubscribed(address indexed channelAddress, address indexed subscriber);\n    event UserUnsubscribed(address indexed channelAddress, address indexed subscriber);\n\n    // Modifiers\n    modifier nonZeroAddress(address addr) {\n        if (addr == address(0)) {\n            revert NotificationService__ZeroAddress();\n        }\n        _;\n    }\n\n    modifier notAlreadyCreated(address _channelAddress) {\n        if (channelAddressToChannel[_channelAddress].admin != address(0)) {\n            revert NotificationService__ChannelAlreadyCreated();\n        }\n        _;\n    }\n\n    modifier channelExists(address _channelAddress) {\n        if (channelAddressToChannel[_channelAddress].admin == address(0)) {\n            revert NotificationService__ChannelDoesNotExist();\n        }\n        _;\n    }\n\n    modifier onlyAdmin(address _channelAddress, address caller) {\n        if (caller != channelAddressToChannel[_channelAddress].admin) {\n            revert NotificationService__NotAdmin();\n        }\n        _;\n    }\n\n    modifier isDelegate(address _channelAddress, address delegate) {\n        if (channelAddressToDelegate[_channelAddress][delegate].channelAddress == address(0)) {\n            revert NotificationService__NotADelegate();\n        }\n        _;\n    }\n\n    modifier isActive(address _channelAddress) {\n        if (channelAddressToChannel[_channelAddress].channelState != ChannelState.ACTIVE) {\n            revert NotificationService__ChannelNotActive();\n        }\n        _;\n    }\n\n    modifier isMuted(address _channelAddress) {\n        if (channelAddressToChannel[_channelAddress].channelState != ChannelState.MUTED) {\n            revert NotificationService__ChannelNotMuted();\n        }\n        _;\n    }\n\n    modifier isSubscribed(address _recipient, address _channelAddress) {\n        if (\n            channelAddressToUserSubscription[_channelAddress][_recipient].channelAddress ==\n            address(0)\n        ) {\n            revert NotificationService__UserNotSubscribed();\n        }\n        _;\n    }\n\n    modifier onlyAdminOrDelegate(address _channelAddress, address caller) {\n        if (\n            !(caller == channelAddressToChannel[_channelAddress].admin ||\n                caller == channelAddressToDelegate[_channelAddress][caller].delegate)\n        ) {\n            revert NotificationService__NeitherAdminNorDelegate();\n        }\n        _;\n    }\n\n    modifier notAlreadySubscribed(address _channelAddress, address caller) {\n        if (\n            channelAddressToUserSubscription[_channelAddress][caller].channelAddress != address(0)\n        ) {\n            revert NotificationService__UserAlreadySubscribed();\n        }\n        _;\n    }\n\n    ///////////////////////\n    /// Admin Functions///\n    //////////////////////\n    function createChannel(\n        address _channelAddress,\n        string memory _channelName,\n        string memory _channelDescription\n    ) external nonZeroAddress(_channelAddress) notAlreadyCreated(_channelAddress) {\n        Channel memory newChannel = Channel(\n            _channelAddress,\n            msg.sender,\n            _channelName,\n            _channelDescription,\n            ChannelState.ACTIVE,\n            new address[](0),\n            new address[](0)\n        );\n        channelAddressToChannel[_channelAddress] = newChannel;\n        channelCounter++;\n        emit ChannelCreated(_channelAddress, msg.sender, _channelName, _channelDescription);\n    }\n\n    function addDelegate(address _channelAddress, address delegate)\n        external\n        nonZeroAddress(delegate)\n        nonZeroAddress(_channelAddress)\n        channelExists(_channelAddress)\n        onlyAdmin(_channelAddress, msg.sender)\n    {\n        uint256 delegateIndex = channelAddressToChannel[_channelAddress].delegates.length;\n        channelAddressToChannel[_channelAddress].delegates.push(delegate);\n        Delegate memory newDelegate = Delegate(_channelAddress, delegate, delegateIndex);\n        channelAddressToDelegate[_channelAddress][delegate] = newDelegate;\n        emit DelegateAdded(_channelAddress, delegate);\n    }\n\n    function removeDelegate(address _channelAddress, address delegate)\n        external\n        nonZeroAddress(delegate)\n        nonZeroAddress(_channelAddress)\n        channelExists(_channelAddress)\n        onlyAdmin(_channelAddress, msg.sender)\n        isDelegate(_channelAddress, delegate)\n    {\n        uint256 _delegateIndex = channelAddressToDelegate[_channelAddress][delegate].delegateIndex;\n        address[] memory newDelegates = removeElementFromArray(\n            channelAddressToChannel[_channelAddress].delegates,\n            _delegateIndex\n        );\n        channelAddressToChannel[_channelAddress].delegates = newDelegates;\n        delete channelAddressToDelegate[_channelAddress][delegate];\n        emit DelegateRemoved(_channelAddress, delegate);\n    }\n\n    function muteChannel(address _channelAddress)\n        external\n        channelExists(_channelAddress)\n        onlyAdmin(_channelAddress, msg.sender)\n        isActive(_channelAddress)\n    {\n        channelAddressToChannel[_channelAddress].channelState = ChannelState.MUTED;\n        emit ChannelMuted(_channelAddress);\n    }\n\n    function unmuteChannel(address _channelAddress)\n        external\n        channelExists(_channelAddress)\n        onlyAdmin(_channelAddress, msg.sender)\n        isMuted(_channelAddress)\n    {\n        channelAddressToChannel[_channelAddress].channelState = ChannelState.ACTIVE;\n        emit ChannelUnmuted(_channelAddress);\n    }\n\n    function deleteChannel(address _channelAddress)\n        external\n        channelExists(_channelAddress)\n        onlyAdmin(_channelAddress, msg.sender)\n    {\n        // update channelAddressToDelegate mapping\n        for (uint256 i = 0; i < channelAddressToChannel[_channelAddress].delegates.length; i++) {\n            delete channelAddressToDelegate[_channelAddress][\n                channelAddressToChannel[_channelAddress].delegates[i]\n            ];\n        }\n        // update channelAddressToUserSubscription mapping\n        for (uint256 i = 0; i < channelAddressToChannel[_channelAddress].subsribers.length; i++) {\n            delete channelAddressToUserSubscription[_channelAddress][\n                channelAddressToChannel[_channelAddress].subsribers[i]\n            ];\n        }\n        delete channelAddressToChannel[_channelAddress];\n        emit ChannelDeleted(_channelAddress);\n    }\n\n    //////////////////////////////////\n    // Admin or Delegate Functions //\n    /////////////////////////////////\n    function sendNotification(\n        address _channelAddress,\n        address _recipient,\n        string memory _message\n    )\n        public\n        channelExists(_channelAddress)\n        onlyAdminOrDelegate(_channelAddress, msg.sender)\n        isSubscribed(_recipient, _channelAddress)\n    {\n        Notification memory notification = Notification(_channelAddress, _recipient, _message);\n        emit NotificationGenerated(_channelAddress, _recipient, notification);\n    }\n\n    function broadcastNotification(address _channelAddress, string memory _message)\n        public\n        channelExists(_channelAddress)\n        onlyAdminOrDelegate(_channelAddress, msg.sender)\n    {\n        for (uint256 i = 0; i < channelAddressToChannel[_channelAddress].subsribers.length; i++) {\n            sendNotification(\n                _channelAddress,\n                channelAddressToChannel[_channelAddress].subsribers[i],\n                _message\n            );\n        }\n    }\n\n    //////////////////////////////\n    ////// User Functions ////////\n    /////////////////////////////\n    function subscribe(address _channelAddress)\n        external\n        channelExists(_channelAddress)\n        notAlreadySubscribed(_channelAddress, msg.sender)\n    {\n        uint256 subscriberIndex = channelAddressToChannel[_channelAddress].subsribers.length;\n        channelAddressToChannel[_channelAddress].subsribers.push(msg.sender);\n        Subscription memory newSubscription = Subscription(\n            _channelAddress,\n            msg.sender,\n            subscriberIndex\n        );\n        channelAddressToUserSubscription[_channelAddress][msg.sender] = newSubscription;\n        emit UserSubscribed(_channelAddress, msg.sender);\n    }\n\n    function unsubscribe(address _channelAddress)\n        external\n        channelExists(_channelAddress)\n        isSubscribed(msg.sender, _channelAddress)\n    {\n        uint256 _subscriberIndex = channelAddressToUserSubscription[_channelAddress][msg.sender]\n            .subscriberIndex;\n        address[] memory newSubscribers = removeElementFromArray(\n            channelAddressToChannel[_channelAddress].subsribers,\n            _subscriberIndex\n        );\n        channelAddressToChannel[_channelAddress].subsribers = newSubscribers;\n        delete channelAddressToUserSubscription[_channelAddress][msg.sender];\n        emit UserUnsubscribed(_channelAddress, msg.sender);\n    }\n\n    // view or pure functions\n\n    function removeElementFromArray(address[] memory arr, uint256 index)\n        private\n        pure\n        returns (address[] memory)\n    {\n        address[] memory result = new address[](arr.length - 1);\n        uint256 i = 0;\n        uint256 j = 0;\n        for (; i < arr.length; i++) {\n            if (i == index) {\n                continue;\n            }\n            result[j] = arr[i];\n            j++;\n        }\n        return result;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}